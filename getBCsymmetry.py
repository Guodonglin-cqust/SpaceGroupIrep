#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
#------------------by Gui-Bin Liu  goodluck.liu@gmail.com---------------
#-------------- 2020-02-07 15:09:47 ---------------
#-------------- 2020-04-13 03:15:00 --------------- fix a problem of np.select in write_poscar
#-------------- 2020-05-14 02:24:00 --------------- add get_BZ_type

import os, sys, argparse, re
import numpy as np
from numpy import sin,cos,tan,sqrt
from numpy.linalg import det
from CifFile import ReadCif
import spglib as spg

atom_label2number={'N/A':0};    atom_number2label={}
i=1
for j in \
( 'H', 'He', 'Li', 'Be',  'B',  'C',  'N',  'O',  'F', 'Ne',
 'Na', 'Mg', 'Al', 'Si',  'P',  'S',  'Cl', 'Ar', 'K', 'Ca',
 'Sc', 'Ti',  'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn',
 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr',  'Y', 'Zr',
 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn',
 'Sb', 'Te',  'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd',
 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb',
 'Lu', 'Hf', 'Ta',  'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg',
 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th',
 'Pa',  'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 
 'Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds'): 
    atom_label2number[j]=i
    atom_number2label[i]=j; i+=1
atom_label2number['D']=1

JonesHex={}
JonesCub={}
JonesCub['[[1,0,0],[0,1,0],[0,0,1]]']='E'
JonesCub['[[1,0,0],[0,-1,0],[0,0,-1]]']='C2x'
JonesCub['[[-1,0,0],[0,1,0],[0,0,-1]]']='C2y'
JonesCub['[[-1,0,0],[0,-1,0],[0,0,1]]']='C2z'
JonesCub['[[0,0,1],[1,0,0],[0,1,0]]']='C31+'
JonesCub['[[0,0,-1],[1,0,0],[0,-1,0]]']='C32+'
JonesCub['[[0,0,-1],[-1,0,0],[0,1,0]]']='C33+'
JonesCub['[[0,0,1],[-1,0,0],[0,-1,0]]']='C34+'
JonesCub['[[0,1,0],[0,0,1],[1,0,0]]']='C31-'
JonesCub['[[0,1,0],[0,0,-1],[-1,0,0]]']='C32-'
JonesCub['[[0,-1,0],[0,0,1],[-1,0,0]]']='C33-'
JonesCub['[[0,-1,0],[0,0,-1],[1,0,0]]']='C34-'
JonesCub['[[1,0,0],[0,0,-1],[0,1,0]]']='C4x+'
JonesCub['[[0,0,1],[0,1,0],[-1,0,0]]']='C4y+'
JonesCub['[[0,-1,0],[1,0,0],[0,0,1]]']='C4z+'
JonesCub['[[1,0,0],[0,0,1],[0,-1,0]]']='C4x-'
JonesCub['[[0,0,-1],[0,1,0],[1,0,0]]']='C4y-'
JonesCub['[[0,1,0],[-1,0,0],[0,0,1]]']='C4z-'
JonesCub['[[0,1,0],[1,0,0],[0,0,-1]]']='C2a'
JonesCub['[[0,-1,0],[-1,0,0],[0,0,-1]]']='C2b'
JonesCub['[[0,0,1],[0,-1,0],[1,0,0]]']='C2c'
JonesCub['[[-1,0,0],[0,0,1],[0,1,0]]']='C2d'
JonesCub['[[0,0,-1],[0,-1,0],[-1,0,0]]']='C2e'
JonesCub['[[-1,0,0],[0,0,-1],[0,-1,0]]']='C2f'
JonesCub['[[-1,0,0],[0,-1,0],[0,0,-1]]']='I'
JonesCub['[[-1,0,0],[0,1,0],[0,0,1]]']='mx'
JonesCub['[[1,0,0],[0,-1,0],[0,0,1]]']='my'
JonesCub['[[1,0,0],[0,1,0],[0,0,-1]]']='mz'
JonesCub['[[0,0,-1],[-1,0,0],[0,-1,0]]']='S61-'
JonesCub['[[0,0,1],[-1,0,0],[0,1,0]]']='S62-'
JonesCub['[[0,0,1],[1,0,0],[0,-1,0]]']='S63-'
JonesCub['[[0,0,-1],[1,0,0],[0,1,0]]']='S64-'
JonesCub['[[0,-1,0],[0,0,-1],[-1,0,0]]']='S61+'
JonesCub['[[0,-1,0],[0,0,1],[1,0,0]]']='S62+'
JonesCub['[[0,1,0],[0,0,-1],[1,0,0]]']='S63+'
JonesCub['[[0,1,0],[0,0,1],[-1,0,0]]']='S64+'
JonesCub['[[-1,0,0],[0,0,1],[0,-1,0]]']='S4x-'
JonesCub['[[0,0,-1],[0,-1,0],[1,0,0]]']='S4y-'
JonesCub['[[0,1,0],[-1,0,0],[0,0,-1]]']='S4z-'
JonesCub['[[-1,0,0],[0,0,-1],[0,1,0]]']='S4x+'
JonesCub['[[0,0,1],[0,-1,0],[-1,0,0]]']='S4y+'
JonesCub['[[0,-1,0],[1,0,0],[0,0,-1]]']='S4z+'
JonesCub['[[0,-1,0],[-1,0,0],[0,0,1]]']='mda'
JonesCub['[[0,1,0],[1,0,0],[0,0,1]]']='mdb'
JonesCub['[[0,0,-1],[0,1,0],[-1,0,0]]']='mdc'
JonesCub['[[1,0,0],[0,0,-1],[0,-1,0]]']='mdd'
JonesCub['[[0,0,1],[0,1,0],[1,0,0]]']='mde'
JonesCub['[[1,0,0],[0,0,1],[0,1,0]]']='mdf'
JonesHex['[[1,0,0],[0,1,0],[0,0,1]]']='E'
JonesHex['[[1,-1,0],[1,0,0],[0,0,1]]']='C6+'
JonesHex['[[0,-1,0],[1,-1,0],[0,0,1]]']='C3+'
JonesHex['[[-1,0,0],[0,-1,0],[0,0,1]]']='C2'
JonesHex['[[-1,1,0],[-1,0,0],[0,0,1]]']='C3-'
JonesHex['[[0,1,0],[-1,1,0],[0,0,1]]']='C6-'
JonesHex['[[-1,1,0],[0,1,0],[0,0,-1]]']='C21p'
JonesHex['[[1,0,0],[1,-1,0],[0,0,-1]]']='C22p'
JonesHex['[[0,-1,0],[-1,0,0],[0,0,-1]]']='C23p'
JonesHex['[[1,-1,0],[0,-1,0],[0,0,-1]]']='C21pp'
JonesHex['[[-1,0,0],[-1,1,0],[0,0,-1]]']='C22pp'
JonesHex['[[0,1,0],[1,0,0],[0,0,-1]]']='C23pp'
JonesHex['[[-1,0,0],[0,-1,0],[0,0,-1]]']='I'
JonesHex['[[-1,1,0],[-1,0,0],[0,0,-1]]']='S3-'
JonesHex['[[0,1,0],[-1,1,0],[0,0,-1]]']='S6-'
JonesHex['[[1,0,0],[0,1,0],[0,0,-1]]']='mh'
JonesHex['[[1,-1,0],[1,0,0],[0,0,-1]]']='S6+'
JonesHex['[[0,-1,0],[1,-1,0],[0,0,-1]]']='S3+'
JonesHex['[[1,-1,0],[0,-1,0],[0,0,1]]']='md1'
JonesHex['[[-1,0,0],[-1,1,0],[0,0,1]]']='md2'
JonesHex['[[0,1,0],[1,0,0],[0,0,1]]']='md3'
JonesHex['[[-1,1,0],[0,1,0],[0,0,1]]']='mv1'
JonesHex['[[1,0,0],[1,-1,0],[0,0,1]]']='mv2'
JonesHex['[[0,-1,0],[-1,0,0],[0,0,1]]']='mv3'

def getJonesOper(Rmat,spg_num):
    if(143<=int(spg_num)<=194): Jones=JonesHex
    else:                  Jones=JonesCub
    mat_str=str(np.round(Rmat).astype(int).tolist()).replace(' ','')
    if mat_str not in Jones: return 'N/A'
    else: return Jones[mat_str]

brav_latt=("TricPrim","MonoPrim","MonoBase","OrthPrim","OrthBase","OrthBody","OrthFace",
           "TetrPrim","TetrBody","TrigPrim","HexaPrim","CubiPrim","CubiFace","CubiBody")

def getSGlatt(SGNo):
   if(SGNo>230 or SGNo<1): print("Warning: getSGlatt(SGNo) ",SGNo," out of range."); return
   BLNo={}
   BLNo["TricPrim"]=(1,2)
   BLNo["MonoPrim"]=(3,4,6,7,10,11,13,14)
   BLNo["MonoBase"]=(5,8,9,12,15)
   BLNo["OrthPrim"]=(16,17,18,19,25,26,27,28,29,30,31,32,33,34,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62)
   BLNo["OrthBase"]=(20,21,35,36,37,38,39,40,41,63,64,65,66,67,68)
   BLNo["OrthBody"]=(23,24,44,45,46,71,72,73,74)
   BLNo["OrthFace"]=(22,42,43,69,70)
   BLNo["TetrPrim"]=(75,76,77,78,81,83,84,85,86,89,90,91,92,93,94,95,96,99,100,101,102,103,104,105,106,111,112,113,114,\
                     115,116,117,118,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138)
   BLNo["TetrBody"]=(79,80,82,87,88,97,98,107,108,109,110,119,120,121,122,139,140,141,142)
   BLNo["TrigPrim"]=(146,148,155,160,161,166,167)
   BLNo["HexaPrim"]=(143,144,145,147,149,150,151,152,153,154,156,157,158,159,162,163,164,165,168,169,170,171,172,173,174,\
                     175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194)
   BLNo["CubiPrim"]=(195,198,200,201,205,207,208,212,213,215,218,221,222,223,224)
   BLNo["CubiFace"]=(196,202,203,209,210,216,219,225,226,227,228)
   BLNo["CubiBody"]=(197,199,204,206,211,214,217,220,229,230)
   for brav in BLNo:  
       if(SGNo in BLNo[brav]): return brav

OrthBase_C2A=np.mat([[0.5,1,-0.5],[-0.5,1,0.5],[0.5,0,0.5]])  
'''OrthBase_C2A is the bases transformation matrix from the C-base-centered orthorhombic lattice in Tab.3.1 to the
 A-base-centered orthorhombic lattice in the note(v) of Tab.3.1 in the BC book.'''

def Q_and_S_from_spg_to_BC(spgnum, latt=[[]]):
    '''The lattice basic vectors which can generate the operations defined in the BC (means Bradley 
    and Cracknell) Tab.3.7 are named (t1_BC1,t2_BC1,t3_BC1) and (t1_BC2,t2_BC2,t3_BC2) which 
    corresond to the first line and second line in Tab.3.7 respectively. These BC1 and BC2 basic vectors
    are compitable with the ones defined in BC Tab.3.1 but additional rotations may be needed to 
    give the same form in Tab.3.1. 
    
    Transformation matrix (Q) transforms the idealized standard lattice (as',bs',cs') from spglib (also the 
    same with ITA) to BC2 by (t1_BC2,t2_BC2,t3_BC2)=(as',bs',cs').Q. To result in the same form
    in Tab.3.1, say (t1'_BC2,t2'_BC2,t3'_BC2), a rotation S1 is needed, that is 
    (t1_BC2', t2_BC2', t3_BC2')=S1.(t1_BC2,t2_BC2,t3_BC2)=S1.(as',bs',cs').Q
    However, Tab.3.7 uses different orientations in the first line (i.e. BC1) for some spacegroups, 
    a transformation matrix U is needed to convert BC2 to BC1,
    (t1_BC1,t2_BC1,t3_BC1)=(t1_BC2,t2_BC2,t3_BC2).U.  
    The BC1 basic vectors also maybe need a rotation S to convert it to the Tab.3.1 form
    (t1_BC1', t2_BC1', t3_BC1')=S.(t1_BC1,t2_BC1,t3_BC1)=S.(as',bs',cs').Q.U.  
    If we start with BC2', then (t1_BC2', t2_BC2', t3_BC2').U also need a rotation to the BC1' form
    (t1_BC1', t2_BC1', t3_BC1')=S2.(t1_BC2', t2_BC2', t3_BC2').U=S2.S1.(as',bs',cs').Q.U
    Then we can combine the to rotations S1 and S2 to form S=S2.S1.
    
    Thus, the rotation matrix S has two origins, S1 and S2.  S1 originates from the different lattice 
    directions between the idealized standard lattice in spglib (the same as ITA) and the one in BC Tab.3.1,
    and S2 originates from the different orientions used in Tab.3.7 for some space groups. 
    In fact, it turns out that if S1!=I3 then S2==I3 and if S2!=I3 then S1==I3, which means either
    S1 or S2 takes effect.
    
    This function only gives Q and S. U is given by SG_gen_elem.

    Note that all basic vectors in the above equations are COLUMN vectors.
    For as',bs',cs' see https://atztogo.github.io/spglib/definition.html#def-idealize-cell
    The relations between the basic vectors here and the lattice in get_all_cells are:
    (as',bs',cs')=Lsi^T      (t1_BC2,t2_BC2,t3_BC2)=LBC2^T     (t1_BC1,t2_BC1,t3_BC1)=LBC1^T    (t1,t2,t3)=LBC^T

    Parameter latt is not used for brav other than "MonoPrim" and "MonoBase", otherwise it should be the idealized 
    standard lattice from spglib to calculate the angle between as' and cs', which is also the angle gamma between t1 and t2.
    '''
    cg=sg=0
    t=sqrt(3)/2
    brav=getSGlatt(spgnum)
    if brav in ("MonoPrim","MonoBase"):
        # latt is only used in monoclinic system to get the sin and cos of gamma angle
        if len(latt)!=3: print("\nError: Parameter latt is needed for monoclinic crystal system!\n"); exit(1)
        cg=np.dot(latt[0],latt[2])/sqrt(np.dot(latt[0],latt[0])*np.dot(latt[2],latt[2]))
        sg=sqrt(1-cg**2)
    QS1={"TricPrim" : ([[1,0,0],[0,1,0],[0,0,1]],[[1,0,0],[0,1,0],[0,0,1]]),
        "MonoPrim"  : ([[0,1,0],[0,0,1],[1,0,0]],[[sg,0,-cg],[-cg,0,-sg],[0,1,0]]),
        "MonoBase"  : ([[0,0.5,0.5],[0,-0.5,0.5],[1,0,0]],[[sg,0,-cg],[-cg,0,-sg],[0,1,0]]),
        "OrthPrim"  : ([[0,1,0],[-1,0,0],[0,0,1]],[[1,0,0],[0,1,0],[0,0,1]]),
        "OrthBase"  : ([[0.5,0.5,0],[-0.5,0.5,0],[0,0,1]],[[1,0,0],[0,1,0],[0,0,1]]),
        "OrthBody"  : ([[0.5,-0.5,0.5],[0.5,-0.5,-0.5],[0.5,0.5,-0.5]],[[1,0,0],[0,1,0],[0,0,1]]),
        "OrthFace"  : ([[0.5,0,0.5],[0,-0.5,-0.5],[0.5,0.5,0]],[[1,0,0],[0,1,0],[0,0,1]]),
        "TetrPrim"  : ([[1,0,0],[0,1,0],[0,0,1]],[[1,0,0],[0,1,0],[0,0,1]]),
        "TetrBody"  : ([[-0.5,0.5,0.5],[0.5,-0.5,0.5],[0.5,0.5,-0.5]],[[1,0,0],[0,1,0],[0,0,1]]),
        "TrigPrim"  : ([[2./3,-1./3,-1./3],[1./3,1./3,-2./3],[1./3,1./3,1./3]],[[-0.5,t,0],[-t,-0.5,0],[0,0,1]]),
        "HexaPrim"  : ([[1,0,0],[0,1,0],[0,0,1]],[[0,1,0],[-1,0,0],[0,0,1]]),
        "CubiPrim"  : ([[1,0,0],[0,1,0],[0,0,1]],[[1,0,0],[0,1,0],[0,0,1]]),
        "CubiFace"  : ([[0,0.5,0.5],[0.5,0,0.5],[0.5,0.5,0]],[[1,0,0],[0,1,0],[0,0,1]]),
        "CubiBody"  : ([[-0.5,0.5,0.5],[0.5,-0.5,0.5],[0.5,0.5,-0.5]],[[1,0,0],[0,1,0],[0,0,1]]) }
    if 38<=spgnum<=41:   # These 4 space groups use different basic vectors, refer to BC book Tab.3.1 note (v).
        (Q_C, S1)= QS1[brav]
        Q_A=np.array(Q_C@OrthBase_C2A).tolist()
        Q=Q_A
    else: (Q,S1)=QS1[brav]
    S2_bAc=[[0,1,0],[-1,0,0],[0,0,1]]   # C4z-   # bAc means the orientation "b -a  c"  in the ITA
    S2_bca=[[0,1,0],[0,0,1],[1,0,0]]    # C3(111)-
    S2_Cba=[[0,0,-1],[0,1,0],[1,0,0]]   # C4y-
    S2_aCb=[[1,0,0],[0,0,-1],[0,1,0]]   # C4x+
    S2=np.eye(3)
    if spgnum in [17,19,28,29,31,33,36,46,53,61,70,122]:  S2=S2_bAc
    if spgnum in [38,39,40,41,57]:                        S2=S2_bca
    if spgnum in [51,54]:                                 S2=S2_Cba
    if spgnum in [52,60]:                                 S2=S2_aCb
    S=(np.array(S2)@S1).tolist()
    return (Q,S)

BC_rot_name={
'TricPrim': ['E','I'],'MonoPrim':['E','C2z','I','mz'], 'MonoBase':['E','C2z','I','mz'],
'OrthPrim': ['E','C2x','C2y','C2z','I','mx','my','mz'],'OrthBase':['E','C2x','C2y','C2z','I','mx','my','mz'],
'OrthBody': ['E','C2x','C2y','C2z','I','mx','my','mz'],'OrthFace':['E','C2x','C2y','C2z','I','mx','my','mz'],
'TetrPrim': ['E','C4z+','C2z','C4z-','C2x','C2y','C2a','C2b','I','S4z-','mz','S4z+','mx','my','mda','mdb'],
'TetrBody': ['E','C4z+','C2z','C4z-','C2x','C2y','C2a','C2b','I','S4z-','mz','S4z+','mx','my','mda','mdb'],
'TrigPrim': ['E','C3+','C3-','C21p','C22p','C23p','I','S6-','S6+','md1','md2','md3'],
'HexaPrim': ['E','C6+','C3+','C2','C3-','C6-','C21p','C22p','C23p','C21pp','C22pp','C23pp',
             'I','S3-','S6-','mh','S6+','S3+','md1','md2','md3','mv1','mv2','mv3'],
'CubiPrim': ['E','C2x','C2y','C2z','C31+','C32+','C33+','C34+','C31-','C32-','C33-','C34-',
             'C4x+','C4y+','C4z+','C4x-','C4y-','C4z-','C2a','C2b','C2c','C2d','C2e','C2f',
             'I','mx','my','mz','S61-','S62-','S63-','S64-','S61+','S62+','S63+','S64+',
             'S4x-','S4y-','S4z-','S4x+','S4y+','S4z+','mda','mdb','mdc','mdd','mde','mdf'],
'CubiBody': ['E','C2x','C2y','C2z','C31+','C32+','C33+','C34+','C31-','C32-','C33-','C34-',
             'C4x+','C4y+','C4z+','C4x-','C4y-','C4z-','C2a','C2b','C2c','C2d','C2e','C2f',
             'I','mx','my','mz','S61-','S62-','S63-','S64-','S61+','S62+','S63+','S64+',
             'S4x-','S4y-','S4z-','S4x+','S4y+','S4z+','mda','mdb','mdc','mdd','mde','mdf'],
'CubiFace': ['E','C2x','C2y','C2z','C31+','C32+','C33+','C34+','C31-','C32-','C33-','C34-',
             'C4x+','C4y+','C4z+','C4x-','C4y-','C4z-','C2a','C2b','C2c','C2d','C2e','C2f',
             'I','mx','my','mz','S61-','S62-','S63-','S64-','S61+','S62+','S63+','S64+',
             'S4x-','S4y-','S4z-','S4x+','S4y+','S4z+','mda','mdb','mdc','mdd','mde','mdf'],
}

BC_rot_mat={
'TricPrim': [[[1,0,0],[0,1,0],[0,0,1]], [[-1,0,0],[0,-1,0],[0,0,-1]]],
'MonoPrim': [[[1,0,0],[0,1,0],[0,0,1]], [[-1,0,0],[0,-1,0],[0,0,1]], [[-1,0,0],[0,-1,0],[0,0,-1]], [[1,0,0],[0,1,0],[0,0,-1]]],
'MonoBase': [[[1,0,0],[0,1,0],[0,0,1]], [[-1,0,0],[0,0,-1],[0,-1,0]], [[-1,0,0],[0,-1,0],[0,0,-1]], [[1,0,0],[0,0,1],[0,1,0]]],
'OrthPrim': [[[1,0,0],[0,1,0],[0,0,1]], [[-1,0,0],[0,1,0],[0,0,-1]], [[1,0,0],[0,-1,0],[0,0,-1]], [[-1,0,0],[0,-1,0],[0,0,1]],
             [[-1,0,0],[0,-1,0],[0,0,-1]], [[1,0,0],[0,-1,0],[0,0,1]], [[-1,0,0],[0,1,0],[0,0,1]], [[1,0,0],[0,1,0],[0,0,-1]]],
'OrthBase': [[[1,0,0],[0,1,0],[0,0,1]], [[0,1,0],[1,0,0],[0,0,-1]], [[0,-1,0],[-1,0,0],[0,0,-1]], [[-1,0,0],[0,-1,0],[0,0,1]],
             [[-1,0,0],[0,-1,0],[0,0,-1]], [[0,-1,0],[-1,0,0],[0,0,1]], [[0,1,0],[1,0,0],[0,0,1]], [[1,0,0],[0,1,0],[0,0,-1]]],
'OrthBody': [[[1,0,0],[0,1,0],[0,0,1]], [[0,-1,1],[0,-1,0],[1,-1,0]], [[-1,0,0],[-1,0,1],[-1,1,0]], [[0,1,-1],[1,0,-1],[0,0,-1]],
             [[-1,0,0],[0,-1,0],[0,0,-1]], [[0,1,-1],[0,1,0],[-1,1,0]], [[1,0,0],[1,0,-1],[1,-1,0]], [[0,-1,1],[-1,0,1],[0,0,1]]],
'OrthFace': [[[1,0,0],[0,1,0],[0,0,1]], [[0,0,1],[-1,-1,-1],[1,0,0]], [[-1,-1,-1],[0,0,1],[0,1,0]], [[0,1,0],[1,0,0],[-1,-1,-1]],
             [[-1,0,0],[0,-1,0],[0,0,-1]], [[0,0,-1],[1,1,1],[-1,0,0]], [[1,1,1],[0,0,-1],[0,-1,0]], [[0,-1,0],[-1,0,0],[1,1,1]]],
'TetrPrim': [[[1,0,0],[0,1,0],[0,0,1]], [[0,-1,0],[1,0,0],[0,0,1]], [[-1,0,0],[0,-1,0],[0,0,1]], [[0,1,0],[-1,0,0],[0,0,1]],
             [[1,0,0],[0,-1,0],[0,0,-1]], [[-1,0,0],[0,1,0],[0,0,-1]], [[0,1,0],[1,0,0],[0,0,-1]], [[0,-1,0],[-1,0,0],[0,0,-1]],
             [[-1,0,0],[0,-1,0],[0,0,-1]], [[0,1,0],[-1,0,0],[0,0,-1]], [[1,0,0],[0,1,0],[0,0,-1]], [[0,-1,0],[1,0,0],[0,0,-1]],
             [[-1,0,0],[0,1,0],[0,0,1]], [[1,0,0],[0,-1,0],[0,0,1]], [[0,-1,0],[-1,0,0],[0,0,1]], [[0,1,0],[1,0,0],[0,0,1]]],
'TetrBody': [[[1,0,0],[0,1,0],[0,0,1]], [[0,1,0],[0,1,-1],[-1,1,0]], [[0,1,-1],[1,0,-1],[0,0,-1]], [[1,0,-1],[1,0,0],[1,-1,0]],
             [[-1,0,0],[-1,0,1],[-1,1,0]], [[0,-1,1],[0,-1,0],[1,-1,0]], [[-1,0,1],[0,-1,1],[0,0,1]], [[0,-1,0],[-1,0,0],[0,0,-1]],
             [[-1,0,0],[0,-1,0],[0,0,-1]], [[0,-1,0],[0,-1,1],[1,-1,0]], [[0,-1,1],[-1,0,1],[0,0,1]], [[-1,0,1],[-1,0,0],[-1,1,0]],
             [[1,0,0],[1,0,-1],[1,-1,0]], [[0,1,-1],[0,1,0],[-1,1,0]], [[1,0,-1],[0,1,-1],[0,0,-1]], [[0,1,0],[1,0,0],[0,0,1]]],
'TrigPrim': [[[1,0,0],[0,1,0],[0,0,1]], [[0,0,1],[1,0,0],[0,1,0]], [[0,1,0],[0,0,1],[1,0,0]], [[-1,0,0],[0,0,-1],[0,-1,0]],
             [[0,0,-1],[0,-1,0],[-1,0,0]], [[0,-1,0],[-1,0,0],[0,0,-1]], [[-1,0,0],[0,-1,0], [0,0,-1]], [[0,0,-1],[-1,0,0],[0,-1,0]],
             [[0,-1,0],[0,0,-1],[-1,0,0]], [[1,0,0],[0,0,1],[0,1,0]], [[0,0,1],[0,1,0],[1,0,0]], [[0,1,0],[1,0,0],[0,0,1]]],
'HexaPrim': [[[1,0,0],[0,1,0],[0,0,1]], [[1,-1,0],[1,0,0],[0,0,1]], [[0,-1,0],[1,-1,0],[0,0,1]], [[-1,0,0],[0,-1,0],[0,0,1]],
             [[-1,1,0],[-1,0,0],[0,0,1]], [[0,1,0],[-1,1,0],[0,0,1]], [[-1,1,0],[0,1,0],[0,0,-1]], [[1,0,0],[1,-1,0],[0,0,-1]],
             [[0,-1,0],[-1,0,0],[0,0,-1]], [[1,-1,0], [0,-1,0],[0,0,-1]], [[-1,0,0],[-1,1,0],[0,0,-1]], [[0,1,0],[1,0,0],[0,0,-1]],
             [[-1,0,0],[0,-1,0],[0,0,-1]], [[-1,1,0],[-1,0,0],[0,0,-1]], [[0,1,0],[-1,1,0],[0,0,-1]], [[1,0,0],[0,1,0],[0,0,-1]],
             [[1,-1,0],[1,0,0],[0,0,-1]], [[0,-1,0],[1,-1,0],[0,0,-1]], [[1,-1,0],[0,-1,0],[0,0,1]], [[-1,0,0],[-1,1,0],[0,0,1]],
             [[0,1,0],[1,0,0],[0,0,1]], [[-1,1,0],[0,1,0],[0,0,1]], [[1,0,0],[1,-1,0],[0,0,1]], [[0,-1,0],[-1,0,0],[0,0,1]]],
'CubiPrim': [[[1,0,0],[0,1,0],[0,0,1]], [[1,0,0],[0,-1,0],[0,0,-1]], [[-1,0,0],[0,1,0],[0,0,-1]], [[-1,0,0],[0,-1,0],[0,0,1]],
             [[0,0,1],[1,0,0],[0,1,0]], [[0,0,-1],[1,0,0],[0,-1,0]], [[0,0,-1],[-1,0,0],[0,1,0]], [[0,0,1],[-1,0,0],[0,-1,0]],
             [[0,1,0],[0,0,1],[1,0,0]], [[0,1,0],[0,0,-1],[-1,0,0]], [[0,-1,0],[0,0,1],[-1,0,0]], [[0,-1,0],[0,0,-1],[1,0,0]],
             [[1,0,0],[0,0,-1],[0,1,0]], [[0,0,1],[0,1,0],[-1,0,0]], [[0,-1,0],[1,0,0],[0,0,1]], [[1,0,0],[0,0,1],[0,-1,0]],
             [[0,0,-1],[0,1,0],[1,0,0]], [[0,1,0],[-1,0,0],[0,0,1]], [[0,1,0],[1,0,0],[0,0,-1]], [[0,-1,0],[-1,0,0],[0,0,-1]],
             [[0,0,1],[0,-1,0],[1,0,0]], [[-1,0,0],[0,0,1],[0,1,0]], [[0,0,-1],[0,-1,0],[-1,0,0]], [[-1,0,0],[0,0,-1],[0,-1,0]],
             [[-1,0,0],[0,-1,0],[0,0,-1]], [[-1,0,0],[0,1,0],[0,0,1]], [[1,0,0],[0,-1,0],[0,0,1]], [[1,0,0],[0,1,0],[0,0,-1]],
             [[0,0,-1],[-1,0,0],[0,-1,0]], [[0,0,1],[-1,0,0],[0,1,0]], [[0,0,1],[1,0,0],[0,-1,0]], [[0,0,-1],[1,0,0],[0,1,0]],
             [[0,-1,0],[0,0,-1],[-1,0,0]], [[0,-1,0],[0,0,1],[1,0,0]], [[0,1,0],[0,0,-1],[1,0,0]], [[0,1,0],[0,0,1],[-1,0,0]],
             [[-1,0,0],[0,0,1],[0,-1,0]], [[0,0,-1],[0,-1,0],[1,0,0]], [[0,1,0],[-1,0,0],[0,0,-1]], [[-1,0,0],[0,0,-1],[0,1,0]],
             [[0,0,1],[0,-1,0],[-1,0,0]], [[0,-1,0],[1,0,0],[0,0,-1]], [[0,-1,0],[-1,0,0],[0,0,1]], [[0,1,0],[1,0,0],[0,0,1]],
             [[0,0,-1],[0,1,0],[-1,0,0]], [[1,0,0],[0,0,-1],[0,-1,0]], [[0,0,1],[0,1,0],[1,0,0]], [[1,0,0],[0,0,1],[0,1,0]]],
'CubiFace': [[[1,0,0],[0,1,0],[0,0,1]], [[-1,-1,-1],[0,0,1],[0,1,0]], [[0,0,1],[-1,-1,-1],[1,0,0]], [[0,1,0],[1,0,0],[-1,-1,-1]],
             [[0,0,1],[1,0,0],[0,1,0]], [[0,1,0],[-1,-1,-1],[0,0,1]], [[1,0,0],[0,0,1],[-1,-1,-1]], [[-1,-1,-1],[0,1,0],[1,0,0]],
             [[0,1,0],[0,0,1],[1,0,0]], [[-1,-1,-1],[1,0,0],[0,0,1]], [[1,0,0],[-1,-1,-1],[0,1,0]], [[0,0,1],[0,1,0],[-1,-1,-1]],
             [[0,-1,0],[1,1,1],[-1,0,0]], [[0,-1,0],[0,0,-1],[1,1,1]], [[1,1,1],[0,0,-1],[-1,0,0]], [[0,0,-1],[-1,0,0],[1,1,1]],
             [[1,1,1],[-1,0,0],[0,-1,0]], [[0,0,-1],[1,1,1],[0,-1,0]], [[-1,0,0],[0,-1,0],[1,1,1]], [[0,-1,0],[-1,0,0],[0,0,-1]],
             [[-1,0,0],[1,1,1],[0,0,-1]], [[1,1,1],[0,-1,0],[0,0,-1]], [[0,0,-1],[0,-1,0],[-1,0,0]], [[-1,0,0],[0,0,-1],[0,-1,0]],
             [[-1,0,0],[0,-1,0],[0,0,-1]], [[1,1,1],[0,0,-1],[0,-1,0]], [[0,0,-1],[1,1,1],[-1,0,0]], [[0,-1,0],[-1,0,0],[1,1,1]],
             [[0,0,-1],[-1,0,0],[0,-1,0]], [[0,-1,0],[1,1,1],[0,0,-1]], [[-1,0,0],[0,0,-1],[1,1,1]], [[1,1,1], [0,-1,0],[-1,0,0]],
             [[0,-1,0],[0,0,-1],[-1,0,0]], [[1,1,1],[-1,0,0],[0,0,-1]], [[-1,0,0],[1,1,1],[0,-1,0]], [[0,0,-1],[0,-1,0],[1,1,1]],
             [[0,1,0],[-1,-1,-1],[1,0,0]], [[0,1,0],[0,0,1],[-1,-1,-1]], [[-1,-1,-1],[0,0,1],[1,0,0]], [[0,0,1],[1,0,0],[-1,-1,-1]],
             [[-1,-1,-1],[1,0,0],[0,1,0]], [[0,0,1],[-1,-1,-1],[0,1,0]], [[1,0,0],[0,1,0],[-1,-1,-1]], [[0,1,0],[1,0,0],[0,0,1]],
             [[1,0,0],[-1,-1,-1],[0,0,1]], [[-1,-1,-1],[0,1,0],[0,0,1]], [[0,0,1],[0,1,0],[1,0,0]], [[1,0,0],[0,0,1],[0,1,0]]],
'CubiBody': [[[1,0,0],[0,1,0],[0,0,1]], [[-1,0,0],[-1,0,1],[-1,1,0]], [[0,-1,1],[0,-1,0],[1,-1,0]], [[0,1,-1],[1,0,-1],[0,0,-1]],
             [[0,0,1],[1,0,0],[0,1,0]], [[-1,1,0],[-1,0,0],[-1,0,1]], [[1,-1,0],[0,-1,1],[0,-1,0]], [[0,0,-1],[0,1,-1],[1,0,-1]],
             [[0,1,0],[0,0,1],[1,0,0]], [[0,-1,0],[1,-1,0],[0,-1,1]], [[1,0,-1],[0,0,-1],[0,1,-1]], [[-1,0,1],[-1,1,0],[-1,0,0]],
             [[0,-1,1],[0,0,1],[-1,0,1]], [[1,-1,0],[1,0,-1],[1,0,0]], [[0,1,0],[0,1,-1],[-1,1,0]], [[0,1,-1],[-1,1,0],[0,1,0]],
             [[0,0,1],[-1,0,1],[0,-1,1]], [[1,0,-1],[1,0,0],[1,-1,0]], [[-1,0,1],[0,-1,1],[0,0,1]], [[0,-1,0],[-1,0,0],[0,0,-1]],
             [[-1,1,0],[0,1,0],[0,1,-1]], [[1,0,0],[1,-1,0],[1,0,-1]], [[0,0,-1], [0,-1,0],[-1,0,0]], [[-1,0,0],[0,0,-1],[0,-1,0]],
             [[-1,0,0],[0,-1,0],[0,0,-1]], [[1,0,0],[1,0,-1],[1,-1,0]], [[0,1,-1],[0,1,0],[-1,1,0]], [[0,-1,1],[-1,0,1],[0,0,1]],
             [[0,0,-1],[-1,0,0],[0,-1,0]], [[1,-1,0],[1,0,0],[1,0,-1]], [[-1,1,0],[0,1,-1],[0,1,0]], [[0,0,1],[0,-1,1],[-1,0,1]],
             [[0,-1,0],[0,0,-1],[-1,0,0]], [[0,1,0],[-1,1,0],[0,1,-1]], [[-1,0,1],[0,0,1], [0,-1,1]], [[1,0,-1],[1,-1,0],[1,0,0]],
             [[0,1,-1],[0,0,-1],[1,0,-1]], [[-1,1,0],[-1,0,1],[-1,0,0]], [[0,-1,0],[0,-1,1],[1,-1,0]], [[0,-1,1],[1,-1,0],[0,-1,0]],
             [[0,0,-1],[1,0,-1],[0,1,-1]], [[-1,0,1],[-1,0,0],[-1,1,0]], [[1,0,-1],[0,1,-1],[0,0,-1]], [[0,1,0],[1,0,0],[0,0,1]],
             [[1,-1,0],[0,-1,0],[0,-1,1]], [[-1,0,0],[-1,1,0],[-1,0,1]], [[0,0,1],[0,1,0],[1,0,0]], [[1,0,0],[0,0,1],[0,1,0]]]
}

BC_mat_to_name={}
for brav in brav_latt:
    toBCname={}
    for name,mat in zip(BC_rot_name[brav],BC_rot_mat[brav]):
        mat_str=str(np.round(mat).astype(int).tolist()).replace(' ','')
        toBCname[mat_str]=name
    BC_mat_to_name[brav]=toBCname

BC_name_to_mat={}
for brav in brav_latt:
    toBCmat={}
    for name,mat in zip(BC_rot_name[brav],BC_rot_mat[brav]):
        toBCmat[name]=mat
    BC_name_to_mat[brav]=toBCmat

def get_BC_rot_name(spgnum, BC_Rmat, latt_type='C'):
    brav=getSGlatt(spgnum)
    # 对于38-41这四个底心正交格子的空间群，ITA（包括spglib）中用的是A底心，而BC书中用的是C底心
    # BC书中的Tab3.1中的基矢也是按C底心给的。BC书中Tab.3.7中的38-41号空间群的第二行生成元是
    # 按A底心格子算的，为了得到这个结果，必须使用不同的基矢定义（见Tab3.1的note(v)），因而旋转
    # 矩阵也会变化。但是BC_mat_to_name中存储的旋转名称对应的是C底心的，所以A底心的矩阵要转成
    # C底心的矩阵才能得到正确的旋转名称。
    # latt_type is either 'A' or 'C', and it's only effective when 38<=spgnum<=41
    if 38<=spgnum<=41 and latt_type=='A':
        Rmat=np.array(OrthBase_C2A@BC_Rmat@OrthBase_C2A.I)
    else:  Rmat=BC_Rmat
    mat_str=str(np.round(Rmat).astype(int).tolist()).replace(' ','')
    if mat_str not in BC_mat_to_name[brav]: return 'N/A'
    else: return BC_mat_to_name[brav][mat_str]

def get_BC_rot_mat(spgnum, rotname, latt_type='C'):
    brav=getSGlatt(spgnum)
    if rotname not in BC_name_to_mat[brav]:  print('Error: Wrong rot name for lattice',brav+'!'); return []
    mat=BC_name_to_mat[brav][rotname]
    if 38<=spgnum<=41 and latt_type=='A':  mat=np.array(OrthBase_C2A.I@mat@OrthBase_C2A)
    return np.array(mat) 

def init_SG_gen_elem():
    global SG_gen_elem
    I3=[[1,0,0],[0,1,0],[0,0,1]];   o=[0,0,0]
    h1=[0.5,0,0];       h2=[0,0.5,0];        h3=[0,0,0.5]
    h12=[0.5,0.5,0];    h23=[0,0.5,0.5];     h13=[0.5,0,0.5];    h123=[0.5,0.5,0.5]
    # tbd=[[-1,0,0],[0,-1,0],[0,0,-1]]
    U38to41=[[-1,0,0],[0,0,1],[0,1,0]]   # bca
    UorthP_bAc=[[0,-1,0],[1,0,0],[0,0,1]]
    UorthB_bAc=[[0,1,0],[0,1,-1],[-1,1,0]]
    UorthP_Cba=[[1,0,0],[0,0,1],[0,-1,0]]
    UorthP_aCb=[[0,0,-1],[0,1,0],[1,0,0]]
    UorthP_bca=[[0,-1,0],[0,0,1],[-1,0,0]]
    UorthF_bAc=[[1,1,1],[0,0,-1],[-1,0,0]]
    UtetrB_bAc=[[0,1,0],[0,1,-1],[-1,1,0]]
    SG_gen_elem={
1:[[['E',o]],o,I3,[]],
2:[[['I',o]],o,I3,[]],
3:[[['C2z',o]],o,I3,[]],
4:[[['C2z',h3]],o,I3,[]],
5:[[['C2z',o]],o,I3,[]],
6:[[['mz',o]],o,I3,[]],
7:[[['mz',h1]],o,I3,[]],
8:[[['mz',o]],o,I3,[]],
9:[[['mz',h1]],o,I3,[]],
10:[[['C2z',o],['I',o]],o,I3,[]],
11:[[['C2z',h3],['I',h3]],[0,0,0.25],I3,[['C2z',h3],['I',o]]],
12:[[['C2z',o],['I',o]],o,I3,[]],
13:[[['C2z',o],['I',h1]],[0.25,0,0],I3,[['C2z',h1],['I',o]]],
14:[[['C2z',h3],['I',h13]],[-0.25,0,0.25],I3,[['C2z',h13],['I',o]]],
15:[[['C2z',o],['I',h1]],[0.25,0,0],I3,[['C2z',h1],['I',o]]],
16:[[['C2x',o],['C2y',o]],o,I3,[]],
17:[[['C2x',h3],['C2y',o]],o,UorthP_bAc,[['C2x',o],['C2y',h3]]],
18:[[['C2x',h12],['C2y',h12]],o,I3,[]],
19:[[['C2x',h23],['C2y',h12]],o,UorthP_bAc,[['C2x',h12],['C2y',h13]]],
20:[[['C2x',o],['C2y',h3]],o,I3,[]],
21:[[['C2x',o],['C2y',o]],o,I3,[]],
22:[[['C2x',o],['C2y',o]],o,I3,[]],
23:[[['C2x',o],['C2y',o]],o,I3,[]],
24:[[['C2x',h23],['C2y',h12]],h1,I3,[['C2x',h12],['C2y',h13]]],
25:[[['mx',o],['my',o]],o,I3,[]],
26:[[['mx',o],['my',h3]],o,I3,[]],
27:[[['mx',h3],['my',h3]],o,I3,[]],
28:[[['mx',h1],['my',o]],[-0.25,0,0],UorthP_bAc,[['mx',h2],['my',h2]]],
29:[[['mx',h1],['my',h3]],[-0.25,0,0],UorthP_bAc,[['mx',h23],['my',h2]]],
30:[[['mx',h13],['my',h3]],[-0.25,0,0],I3,[['mx',h13],['my',h13]]],
31:[[['mx',h13],['my',o]],o,UorthP_bAc,[['mx',o],['my',h23]]],
32:[[['mx',h1],['my',h2]],[-0.25,0.25,0],I3,[['mx',h12],['my',h12]]],
33:[[['mx',h1],['my',h23]],[-0.25,0.25,0],UorthP_bAc,[['mx',h123],['my',h12]]],
34:[[['mx',h13],['my',h23]],[-0.25,0.25,0],I3,[['mx',h123],['my',h123]]],
35:[[['mx',o],['my',o]],o,I3,[]],
36:[[['mx',h3],['my',o]],o,UorthP_bAc,[['mx',o],['my',h3]]],
37:[[['mx',h3],['my',h3]],o,I3,[]],
38:[[['mz',o],['mx',o]],o,U38to41,[['mx',o],['my',o]]],
39:[[['mz',h12],['mx',h12]],o,U38to41,[['mx',h13],['my',h13]]],
40:[[['mz',h3],['mx',h3]],o,U38to41,[['mx',h2],['my',h2]]],
41:[[['mz',h123],['mx',h123]],o,U38to41,[['mx',h123],['my',h123]]],
42:[[['mx',o],['my',o]],o,I3,[]],
43:[[['mx',h2],['my',h1]],[0,0,0.25],I3,[['mx',[0.75,0.75,0.75]],['my',[0.75,0.75,0.75]]]],
44:[[['mx',o],['my',o]],o,I3,[]],
45:[[['mx',h12],['my',h12]],o,I3,[]],
46:[[['mx',h23],['my',h23]],o,UorthB_bAc,[['mx',h13],['my',h13]]],
47:[[['C2x',o],['C2y',o],['I',o]],o,I3,[]],
48:[[['C2x',o],['C2y',o],['I',h123]],o,I3,[]],
49:[[['C2x',o],['C2y',o],['I',h3]],[0,0,0.25],I3,[['C2x',h3],['C2y',h3],['I',o]]],
50:[[['C2x',o],['C2y',o],['I',h12]],o,I3,[]],
51:[[['C2x',h3],['C2y',o],['I',o]],o,UorthP_Cba,[['C2x',h2],['C2y',o],['I',o]]],
52:[[['C2x',h3],['C2y',o],['I',h12]],[0.25,0.25,0],UorthP_aCb,[['C2x',h13],['C2y',h123],['I',o]]],
53:[[['C2x',h3],['C2y',o],['I',h1]],[-0.25,0,0],UorthP_bAc,[['C2x',o],['C2y',h23],['I',o]]],
54:[[['C2x',h3],['C2y',o],['I',h2]],[0,0.25,0],UorthP_Cba,[['C2x',h23],['C2y',h3],['I',o]]],
55:[[['C2x',h12],['C2y',h12],['I',o]],o,I3,[]],
56:[[['C2x',h12],['C2y',h12],['I',h123]],[-0.25,-0.25,-0.25],I3,[['C2x',h23],['C2y',h13],['I',o]]],
57:[[['C2x',h12],['C2y',h12],['I',h2]],[0,0.25,0],UorthP_bca,[['C2x',h1],['C2y',h13],['I',o]]],
58:[[['C2x',h12],['C2y',h12],['I',h3]],[0,0,-0.25],I3,[['C2x',h123],['C2y',h123],['I',o]]],
59:[[['C2x',h12],['C2y',h12],['I',h12]],o,I3,[]],
60:[[['C2x',h12],['C2y',h12],['I',h13]],[-0.25,0,0.25],UorthP_aCb,[['C2x',h12],['C2y',h3],['I',o]]],
61:[[['C2x',h23],['C2y',h12],['I',o]],o,UorthP_bAc,[['C2x',h12],['C2y',h13],['I',o]]],
62:[[['C2x',h23],['C2y',h12],['I',h12]],[0.25,0.25,0],I3,[['C2x',h123],['C2y',h1],['I',o]]],
63:[[['C2x',o],['C2y',h3],['I',o]],o,I3,[]],
64:[[['C2x',o],['C2y',h3],['I',h12]],[0.25,0.25,0],I3,[['C2x',o],['C2y',h123],['I',o]]],
65:[[['C2x',o],['C2y',o],['I',o]],o,I3,[]],
66:[[['C2x',o],['C2y',o],['I',h3]],[0,0,0.25],I3,[['C2x',h3],['C2y',h3],['I',o]]],
67:[[['C2x',o],['C2y',o],['I',h12]],[0.25,0.25,0],I3,[['C2x',o],['C2y',h12],['I',o]]],
#68:[[['C2x',o],['C2y',o],['I',h123]],[-0.25,0.25,0.25],I3,[['C2x',h123],['C2y',h3],['I',o]]],  # original data in the BC book
68:[[['C2x',o],['C2y',o],['I',h123]],o,I3,[]],  #revised
69:[[['C2x',o],['C2y',o],['I',o]],o,I3,[]],
70:[[['C2x',o],['C2y',o],['I',[0.25,0.25,0.25]]],o,UorthF_bAc,[['C2x',o],['C2y',o],['I',[0.75,0.75,0.75]]]],
71:[[['C2x',o],['C2y',o],['I',o]],o,I3,[]],
72:[[['C2x',o],['C2y',o],['I',h12]],[0.25,0.25,0],I3,[['C2x',h12],['C2y',h12],['I',o]]],
73:[[['C2x',h23],['C2y',h12],['I',o]],h1,I3,[['C2x',h12],['C2y',h13],['I',o]]],
74:[[['C2x',h23],['C2y',h12],['I',h12]],[0.75,0.25,0],I3,[['C2x',o],['C2y',h23],['I',o]]],
75:[[['C4z+',o]],o,I3,[]],
76:[[['C4z+',[0,0,0.25]]],o,I3,[]],
77:[[['C4z+',h3]],o,I3,[]],
78:[[['C4z+',[0,0,0.75]]],o,I3,[]],
79:[[['C4z+',o]],o,I3,[]],
80:[[['C4z+',[0.75,0.25,0.5]]],o,I3,[]],
81:[[['S4z+',o]],o,I3,[]],
82:[[['S4z+',o]],o,I3,[]],
83:[[['C4z+',o],['I',o]],o,I3,[]],
84:[[['C4z+',h3],['I',h3]],[0,0,0.25],I3,[['C4z+',h3],['I',o]]],
85:[[['C4z+',h12],['I',h12]],o,I3,[]],
86:[[['C4z+',h123],['I',h123]],o,I3,[]],
87:[[['C4z+',o],['I',o]],o,I3,[]],
88:[[['C4z+',[0.75,0.25,0.5]],['I',[0.75,0.25,0.5]]],o,I3,[]],
89:[[['C4z+',o],['C2x',o]],o,I3,[]],
90:[[['C4z+',o],['C2x',h12]],h1,I3,[['C4z+',h12],['C2x',h12]]],
91:[[['C4z+',[0,0,0.25]],['C2x',o]],[0,0,0.25],I3,[['C4z+',[0,0,0.25]],['C2x',h3]]],
92:[[['C4z+',[0,0,0.25]],['C2x',h12]],[0.5,0,-0.375],I3,[['C4z+',[0.5,0.5,0.25]],['C2x',[0.5,0.5,0.75]]]],
93:[[['C4z+',h3],['C2x',o]],o,I3,[]],
94:[[['C4z+',h3],['C2x',h12]],[0.5,0,0.25],I3,[['C4z+',h123],['C2x',h123]]],
95:[[['C4z+',[0,0,0.75]],['C2x',o]],[0,0,0.25],I3,[['C4z+',[0,0,0.75]],['C2x',h3]]],
96:[[['C4z+',[0,0,0.75]],['C2x',h12]],[0.5,0,-0.125],I3,[['C4z+',[0.5,0.5,0.75]],['C2x',[0.5,0.5,0.25]]]],
97:[[['C4z+',o],['C2x',o]],o,I3,[]],
98:[[['C4z+',[0.75,0.25,0.5]],['C2x',h23]],[0.125,0.125,0],I3,[['C4z+',[0.75,0.25,0.5]],['C2x',[0.75,0.25,0.5]]]],
99:[[['C4z+',o],['mx',o]],o,I3,[]],
100:[[['C4z+',o],['mx',h12]],o,I3,[]],
101:[[['C4z+',h3],['mx',h3]],o,I3,[]],
102:[[['C4z+',h3],['mx',h123]],h1,I3,[['C4z+',h123],['mx',h123]]],
103:[[['C4z+',o],['mx',h3]],o,I3,[]],
104:[[['C4z+',o],['mx',h123]],o,I3,[]],
105:[[['C4z+',h3],['mx',o]],o,I3,[]],
106:[[['C4z+',h3],['mx',h12]],o,I3,[]],
107:[[['C4z+',o],['mx',o]],o,I3,[]],
108:[[['C4z+',o],['mx',h12]],o,I3,[]],
109:[[['C4z+',[0.75,0.25,0.5]],['mx',o]],o,I3,[]],
110:[[['C4z+',[0.75,0.25,0.5]],['mx',h12]],o,I3,[]],
111:[[['S4z+',o],['C2x',o]],o,I3,[]],
112:[[['S4z+',o],['C2x',h3]],o,I3,[]],
113:[[['S4z+',o],['C2x',h12]],o,I3,[]],
114:[[['S4z+',o],['C2x',h123]],o,I3,[]],
115:[[['S4z+',o],['C2a',o]],o,I3,[]],
116:[[['S4z+',o],['C2a',h3]],o,I3,[]],
117:[[['S4z+',o],['C2a',h12]],o,I3,[]],
118:[[['S4z+',o],['C2a',h123]],o,I3,[]],
119:[[['S4z+',o],['C2a',o]],o,I3,[]],
120:[[['S4z+',o],['C2a',h12]],o,I3,[]],
121:[[['S4z+',o],['C2x',o]],o,I3,[]],
122:[[['S4z+',o],['C2x',[0.25,0.75,0.5]]],o,UtetrB_bAc,[['S4z+',o],['C2x',[0.75,0.25,0.5]]]],
123:[[['C4z+',o],['C2x',o],['I',o]],o,I3,[]],
124:[[['C4z+',o],['C2x',o],['I',h3]],[0,0,0.25],I3,[['C4z+',o],['C2x',h3],['I',o]]],
#125:[[['C4z+',h12],['C2x',o],['I',h12]],[0.25,-0.25,0],I3,[['C4z+',h1],['C2x',h2],['I',o]]],   # original data in the BC book
125:[[['C4z+',h12],['C2x',o],['I',h12]],[0.5,0,0],I3,[['C4z+',o],['C2x',o],['I',h12]]],    # revised
126:[[['C4z+',h12],['C2x',o],['I',h123]],h1,I3,[['C4z+',o],['C2x',o],['I',h123]]],
127:[[['C4z+',h12],['C2x',h12],['I',o]],h1,I3,[['C4z+',o],['C2x',h12],['I',o]]],
128:[[['C4z+',h12],['C2x',h12],['I',h3]],[0.5,0,0.25],I3,[['C4z+',o],['C2x',h123],['I',o]]],
129:[[['C4z+',o],['C2x',h12],['I',h12]],h1,I3,[['C4z+',h12],['C2x',h12],['I',h12]]],
130:[[['C4z+',o],['C2x',h12],['I',h123]],[0.5,0,0.25],I3,[['C4z+',h12],['C2x',h123],['I',h12]]],
131:[[['C4z+',h3],['C2x',o],['I',o]],o,I3,[]],
132:[[['C4z+',h3],['C2x',o],['I',h3]],[0,0,0.25],I3,[['C4z+',h3],['C2x',h3],['I',o]]],
133:[[['C4z+',h123],['C2x',o],['I',h12]],[0,0,0.25],I3,[['C4z+',h123],['C2x',h3],['I',h123]]],
134:[[['C4z+',h123],['C2x',o],['I',h123]],o,I3,[]],
135:[[['C4z+',h123],['C2x',h12],['I',o]],h1,I3,[['C4z+',h3],['C2x',h12],['I',o]]],
136:[[['C4z+',h123],['C2x',h12],['I',h3]],[0,0,0.25],I3,[['C4z+',h123],['C2x',h123],['I',o]]],
137:[[['C4z+',h3],['C2x',h12],['I',h12]],[0.5,0,0.25],I3,[['C4z+',h123],['C2x',h123],['I',h123]]],
138:[[['C4z+',h3],['C2x',h12],['I',h123]],h1,I3,[['C4z+',h123],['C2x',h12],['I',h123]]],
139:[[['C4z+',o],['C2x',o],['I',o]],o,I3,[]],
140:[[['C4z+',h12],['C2x',o],['I',h12]],[0.75,0.25,0.5],I3,[['C4z+',o],['C2x',h12],['I',o]]],
#141:[[['C4z+',h2],['C2x',h12],['I',h12]],[0.25,0.25,0],I3,[['C4z+',h2],['C2x',o],['I',o]]],   # original data in the BC book
141:[[['C4z+',h2],['C2x',h12],['I',h12]],[3/8,1/8,1/4],I3,[['C4z+',[3/4,1/4,1/2]],['C2x',[3/4,1/4,1/2]],['I',[3/4,1/4,1/2]]]],  # revised
#142:[[['C4z+',h1],['C2x',h12],['I',o]],o,tbd,[['C4z+',h2],['C2x',h12],['I',o]]],  # original data in the BC book
142:[[['C4z+',h1],['C2x',h12],['I',o]],[1/8,3/8,-1/4],I3,[['C4z+',[3/4,1/4,1/2]],['C2x',[1/4,3/4,1/2]],['I',[3/4,1/4,1/2]]]],  # revised
143:[[['C3+',o]],o,I3,[]],
144:[[['C3+',[0,0,1/3]]],o,I3,[]],
145:[[['C3+',[0,0,2/3]]],o,I3,[]],
146:[[['C3+',o]],o,I3,[]],
147:[[['S6+',o]],o,I3,[]],
148:[[['S6+',o]],o,I3,[]],
149:[[['C3+',o],['C21p',o]],o,I3,[]],
150:[[['C3+',o],['C21pp',o]],o,I3,[]],
151:[[['C3+',[0,0,1/3]],['C21p',[0,0,2/3]]],[0,0,1/6],I3,[['C3+',[0,0,1/3]],['C21p',[0,0,1/3]]]],
152:[[['C3+',[0,0,1/3]],['C21pp',[0,0,2/3]]],o,I3,[]],
153:[[['C3+',[0,0,2/3]],['C21p',[0,0,1/3]]],[0,0,-1/6],I3,[['C3+',[0,0,2/3]],['C21p',[0,0,2/3]]]],
154:[[['C3+',[0,0,2/3]],['C21pp',[0,0,1/3]]],o,I3,[]],
#155:[[['C3+',o],['C21p',o]],o,tbd,[['C3+',o],['C21pp',o]]],  # original data in the BC book
155:[[['C3+',o],['C21p',o]],o,I3,[]], # revised
156:[[['C3+',o],['mv1',o]],o,I3,[]],
157:[[['C3+',o],['md1',o]],o,I3,[]],
158:[[['C3+',o],['mv1',h3]],o,I3,[]],
159:[[['C3+',o],['md1',h3]],o,I3,[]],
#160:[[['C3+',o],['md1',o]],o,tbd,[['C3+',o],['mv1',o]]],  # original data in the BC book
160:[[['C3+',o],['md1',o]],o,I3,[]], # revised
#161:[[['C3+',o],['md1',h123]],o,tbd,[['C3+',o],['mv1',h123]]],  # original data in the BC book
161:[[['C3+',o],['md1',h123]],o,I3,[]], # revised
162:[[['S6+',o],['md1',o]],o,I3,[]],
163:[[['S6+',o],['md1',h3]],o,I3,[]],
164:[[['S6+',o],['mv1',o]],o,I3,[]],
165:[[['S6+',o],['mv1',h3]],o,I3,[]],
#166:[[['S6+',o],['md1',o]],o,tbd,[['S6+',o],['mv1',o]]],  # original data in the BC book
166:[[['S6+',o],['md1',o]],o,I3,[]], # revised
#167:[[['S6+',o],['md1',h123]],o,tbd,[['S6+',o],['mv1',h123]]],  # original data in the BC book
167:[[['S6+',o],['md1',h123]],o,I3,[]], # revised
168:[[['C6+',o]],o,I3,[]],
169:[[['C6+',[0,0,1/6]]],o,I3,[]],
170:[[['C6+',[0,0,5/6]]],o,I3,[]],
171:[[['C6+',[0,0,1/3]]],o,I3,[]],
172:[[['C6+',[0,0,2/3]]],o,I3,[]],
173:[[['C6+',h3]],o,I3,[]],
174:[[['S3+',o]],o,I3,[]],
175:[[['C6+',o],['mh',o]],o,I3,[]],
176:[[['C6+',h3],['mh',o]],[0,0,0.25],I3,[['C6+',h3],['mh',h3]]],
177:[[['C6+',o],['C21p',o]],o,I3,[]],
#178:[[['C6+',[0,0,1/6]],['C21p',o]],o,tbd,[['C6+',[0,0,1/6]],['C21pp',o]]],   # original data in the BC book
178:[[['C6+',[0,0,1/6]],['C21p',o]],[0,0,1/4],I3,[['C6+',[0,0,1/6]],['C21pp',o]]],  # revised
#179:[[['C6+',[0,0,5/6]],['C21p',o]],o,tbd,[['C6+',[0,0,5/6]],['C21pp',o]]],   # original data in the BC book
179:[[['C6+',[0,0,5/6]],['C21p',o]],[0,0,1/4],I3,[['C6+',[0,0,5/6]],['C21pp',o]]],  # revised
180:[[['C6+',[0,0,1/3]],['C21p',o]],o,I3,[]],
181:[[['C6+',[0,0,2/3]],['C21p',o]],o,I3,[]],
#182:[[['C6+',h3],['C21p',o]],o,tbd,[['C6+',h3],['C21pp',o]]],   # original data in the BC book
182:[[['C6+',h3],['C21p',o]],[0,0,1/4],I3,[['C6+',h3],['C21pp',o]]],  # revised
183:[[['C6+',o],['mv1',o]],o,I3,[]],
184:[[['C6+',o],['mv1',h3]],o,I3,[]],
185:[[['C6+',h3],['mv1',h3]],o,I3,[]],
186:[[['C6+',h3],['mv1',o]],o,I3,[]],
187:[[['S3+',o],['mv1',o]],o,I3,[]],
188:[[['S3+',o],['mv1',h3]],[0,0,0.25],I3,[['S3+',h3],['mv1',h3]]],
189:[[['S3+',o],['md1',o]],o,I3,[]],
190:[[['S3+',o],['md1',h3]],[0,0,0.25],I3,[['S3+',h3],['md1',h3]]],
191:[[['C6+',o],['C21p',o],['I',o]],o,I3,[]],
192:[[['C6+',o],['C21p',h3],['I',o]],o,I3,[]],
193:[[['C6+',h3],['C21p',o],['I',o]],o,I3,[]],
194:[[['C6+',h3],['C21p',h3],['I',o]],o,I3,[]],
195:[[['C2z',o],['C2x',o],['C31+',o]],o,I3,[]],
196:[[['C2z',o],['C2x',o],['C31+',o]],o,I3,[]],
197:[[['C2z',o],['C2x',o],['C31+',o]],o,I3,[]],
198:[[['C2z',h13],['C2x',h12],['C31+',o]],o,I3,[]],
199:[[['C2z',h13],['C2x',h12],['C31+',o]],o,I3,[]],
200:[[['C2z',o],['C2x',o],['C31+',o],['I',o]],o,I3,[]],
201:[[['C2z',o],['C2x',o],['C31+',o],['I',h123]],o,I3,[]],
202:[[['C2z',o],['C2x',o],['C31+',o],['I',o]],o,I3,[]],
203:[[['C2z',o],['C2x',o],['C31+',o],['I',[0.25,0.25,0.25]]],o,I3,[]],
204:[[['C2z',o],['C2x',o],['C31+',o],['I',o]],o,I3,[]],
205:[[['C2z',h13],['C2x',h12],['C31+',o],['I',o]],o,I3,[]],
206:[[['C2z',h13],['C2x',h12],['C31+',o],['I',o]],o,I3,[]],
207:[[['C2z',o],['C2x',o],['C2a',o],['C31+',o]],o,I3,[]],
208:[[['C2z',o],['C2x',o],['C2a',h123],['C31+',o]],o,I3,[]],
209:[[['C2z',o],['C2x',o],['C2a',o],['C31+',o]],o,I3,[]],
210:[[['C2z',o],['C2x',o],['C2a',[0.25,0.25,0.25]],['C31+',o]],o,I3,[]],
211:[[['C2z',o],['C2x',o],['C2a',o],['C31+',o]],o,I3,[]],
212:[[['C2z',h13],['C2x',h12],['C2a',[0.25,0.75,0.75]],['C31+',o]],o,I3,[]],
213:[[['C2z',h13],['C2x',h12],['C2a',[0.75,0.25,0.25]],['C31+',o]],o,I3,[]],
214:[[['C2z',h13],['C2x',h12],['C2a',h1],['C31+',o]],o,I3,[]],
215:[[['C2z',o],['C2x',o],['mda',o],['C31+',o]],o,I3,[]],
216:[[['C2z',o],['C2x',o],['mda',o],['C31+',o]],o,I3,[]],
217:[[['C2z',o],['C2x',o],['mda',o],['C31+',o]],o,I3,[]],
218:[[['C2z',o],['C2x',o],['mda',h123],['C31+',o]],o,I3,[]],
219:[[['C2z',o],['C2x',o],['mda',h123],['C31+',o]],o,I3,[]],
220:[[['C2z',h13],['C2x',h12],['mda',h1],['C31+',o]],o,I3,[]],
221:[[['C2z',o],['C2x',o],['C2a',o],['C31+',o],['I',o]],o,I3,[]],
222:[[['C2z',o],['C2x',o],['C2a',o],['C31+',o],['I',h123]],o,I3,[]],
223:[[['C2z',o],['C2x',o],['C2a',h123],['C31+',o],['I',o]],o,I3,[]],
224:[[['C2z',o],['C2x',o],['C2a',h123],['C31+',o],['I',h123]],o,I3,[]],
225:[[['C2z',o],['C2x',o],['C2a',o],['C31+',o],['I',o]],o,I3,[]],
226:[[['C2z',o],['C2x',o],['C2a',o],['C31+',o],['I',h123]],[0.25,0.25,0.25],I3,[['C2z',o],['C2x',o],['C2a',h123],['C31+',o],['I',o]]],
227:[[['C2z',o],['C2x',o],['C2a',[0.25,0.25,0.25]],['C31+',o],['I',[0.25,0.25,0.25]]],o,I3,[]],
228:[[['C2z',o],['C2x',o],['C2a',[0.25,0.25,0.25]],['C31+',o],['I',[0.75,0.75,0.75]]],o,I3,[]],
229:[[['C2z',o],['C2x',o],['C2a',o],['C31+',o],['I',o]],o,I3,[]],
230:[[['C2z',h13],['C2x',h12],['C2a',h1],['C31+',o],['I',o]],o,I3,[]]}
#------------------ end of init_SG_gen_elem() ----------------------
init_SG_gen_elem()
  
def read_poscar(file):
    poscar=open(file,'r')
    nl=0
    # global alat, atom_pos, atom_types, type_nums, natom, atom_numbers
    alat=np.empty((3,3))
    while True:
        line=poscar.readline();  ss=line.split();  nl+=1
        if not line: break
#       print(nl,ss)    # for debug
        if(nl==2): scale=float(ss[0])
        if(3<=nl<=5): alat[nl-3]=np.array(list(map(float,ss)))*scale
        if nl==6:
            noatomtypes=False
            if ss[0].isnumeric(): noatomtypes=True; nl+=1    # for old POSCAR format without atom types
            else: atom_types=np.array(ss)
        if(nl==7): type_nums=np.array(list(map(int,ss))); natom=np.sum(type_nums); atom_pos=np.empty((natom,3))  
        if(nl==8): 
            if ss[0][0]=='s' or ss[0][0]=='S': nl-=1; continue 
            elif ss[0][0]=='d' or ss[0][0]=='D': Direct=True
            else: Direct=False
        if(9<=nl<=8+natom):  atom_pos[nl-9]=np.array(list(map(float,ss[0:3])))
    if noatomtypes: atom_types=["N/A"]*type_nums.size
    if(not Direct):
        atom_pos=list(map(lambda p: np.array(np.dot(np.mat(alat).T.I, p*scale))[0], atom_pos))
    atom_numbers=[]
    for (i,j) in zip(atom_types,type_nums): atom_numbers+=[atom_label2number[i]]*j
    return (alat,atom_pos,atom_numbers)

def write_poscar(cell, filename):
    (latt,atom_pos,atom_number)=map(np.array,cell)
    (uan,idx,inv)=np.unique(atom_number, return_index=True,return_inverse=True)
    idx=np.sort(idx)
    uatm=atom_number[idx]
    newidx=[];   natm=[0]*len(uatm)
    for i,an in enumerate(uatm):
        condlist=[atom_number==an]
        choicelist=[list(range(len(atom_number)))]
        tmp=np.sort(np.unique(np.select(condlist,choicelist,-1))).tolist()  # -1 for False
        if(-1 in tmp): tmp.remove(-1)
        natm[i]=len(tmp)
        newidx+=tmp
    file=open(filename,"w")
    file.write(re.sub(".vasp$","",filename)+": generated by getBCsymmetry.py\n")
    file.write("     1\n")
    for i in latt:
        file.write("%20.15f %20.15f %20.15f\n"%tuple(i))
    file.write(("%4s "*len(uatm))%tuple(list(map(lambda i:atom_number2label[i],uatm)))+"\n") 
    file.write(("%4d "*len(natm))%tuple(natm)+"\n") 
    file.write("Direct\n")
    for i in atom_pos[newidx]:
        file.write("%20.15f %20.15f %20.15f"%tuple(i)+"\n")
    file.close()

'''Note that we can use ase.io to read file, it's very easy.
import ase.io
def ase_read_file(filename):
    s=ase.io.read(filename)
    return (s.cell, s.get_scaled_positions(), s.get_atomic_numbers())
'''

def get_all_cells(dataset, prec=1e-5):
    ''' Get all the cells in the cell-changing process. There are six cells in total.
    1. The input cell
    2. The spglib standardlized cell before idealization.
    3. The spglib standardlized cell after idealization, with origin and orientation of the 
       crystal the same as in ITA (first setting).
    4. The cell using the BC basic vectors in Tab.3.1 assuming the vectors a,b,c are the basic
       vectors of the previous step 3. This corresponds to the second line of the revised Tab.3.7.
    5. The cell generating the BC operations, i.e. the ones in the first line of Tab.3.7.
    6. The final cell obtained by rotating the crystal to make the basic vectors literally 
       the same as in Tab.3.1.
    '''    
    ndig=15
    spgnum=dataset['number']   
    p0=np.around(dataset['origin_shift'],ndig)
    P=np.around(dataset["transformation_matrix"],ndig)
    (Q,S)=Q_and_S_from_spg_to_BC(spgnum,dataset['std_lattice'])
    (gen1,t0,U,gen2)=SG_gen_elem[spgnum]
    Lsi =std_lat_after_idl=chop(dataset["std_lattice"])
    Ls  =std_lat_before_idl=chop(std_lat_after_idl@np.mat(dataset['std_rotation_matrix']).I.T)
    L0  =input_lat=chop(np.mat(dataset['transformation_matrix']).T@std_lat_before_idl)
    LBC2=(np.array(Lsi).T@Q).T
    LBC1=(np.array(LBC2).T@U).T
    LBC=(S@np.array(LBC1).T).T
    atom_numbers=dataset['std_types']
    pos_s=np.round(dataset['std_positions'],ndig)
    pos_0=mymod(np.round(list(map(lambda v: np.dot(np.mat(P).I,v-p0).tolist()[0], pos_s)),ndig),1)
    pos_BC2=mymod(np.round(list(map(lambda v: np.dot(np.mat(Q).I,v).tolist()[0], pos_s)),ndig),1)
    pos_BC1=mymod(np.round(list(map(lambda v: np.dot(np.mat(U).I,v).tolist()[0], pos_BC2)),ndig)+t0,1)
    pos_0=np.array(pos_0);    pos_BC1=np.array(pos_BC1);    pos_BC2=np.array(pos_BC2)
    atom_numbers0=atom_numbers.copy()
    atom_numbers1=atom_numbers.copy()
    if np.round(det(P),2)<1:     # remove duplicate atom positions
        nn=int(np.round(-np.log10(prec)))
        tmp=np.round(pos_0,nn)
        (tmp,idx)=np.unique(tmp,axis=0,return_index=True)
        idx=np.sort(idx)
        pos_0=pos_0[idx]
        atom_numbers0=atom_numbers[idx]
    if np.round(det(Q),2)<1:     # remove duplicate atom positions
        nn=int(np.round(-np.log10(prec)))
        tmp=np.round(pos_BC2,nn)
        (tmp,idx)=np.unique(tmp,axis=0,return_index=True)
        idx=np.sort(idx)
        pos_BC2=pos_BC2[idx]
        pos_BC1=pos_BC1[idx]
        atom_numbers1=atom_numbers[idx]
    cells={}
    cells[1]=(np.around(L0,ndig),    pos_0,   atom_numbers0)
    cells[2]=(np.around(Ls,ndig),    pos_s,   atom_numbers)
    cells[3]=(np.around(Lsi,ndig),   pos_s,   atom_numbers)
    cells[4]=(np.around(LBC2,ndig),  pos_BC2, atom_numbers1)
    cells[5]=(np.around(LBC1,ndig),  pos_BC1, atom_numbers1)
    cells[6]=(np.around(LBC,ndig),   pos_BC1, atom_numbers1)
    return cells

def output_poscar(dataset, filename, arg_select, prec=1e-5):
    bn=os.path.basename(filename);    bns=bn.split('.')
    if len(bns)>1: bn='.'.join(bns[:-1])
    #print(bn)
    cells=get_all_cells(dataset, prec)
    if arg_select=='a': ss=[1,2,3,4,5,6]
    else:
        ss=[]
        for c in list(arg_select):
            if c.isnumeric() and 1<=int(c)<=6:  ss+=[int(c)]
    for s in ss:
        fn=bn+"_"+str(s)+".vasp"
        print("File "+fn+" is output.")
        write_poscar(cells[s], fn)

def chop(x, eps=1e-14):
    if(isinstance(x,str)): return x
    if(np.array([x]).ndim==1):
        if(abs(x)<eps): return 0
        else: return x
    else: return list(map(chop,np.array(x)))

def mymod(x,y):
    eps=1e-14
    if(np.array([x]).ndim==1):
        m=x%y
        if(abs(m-y)<eps): return 0
        else: return m
    else: return list(map(lambda L:mymod(L,y),np.array(x)))

def list2tuple(L):
    if type(L)==list or type(L)==np.ndarray:
        return tuple(map(list2tuple,L))
    else: return L

def myreadcif(filename, symprec=1e-5):
    def rmprs(numstr):    # remove (2) in the number string like 3.45(2)
        if(type(numstr)!=list):
            return float(re.sub(r"\(.*\)","",numstr))
        else:
            return list(map(rmprs,numstr))
    def poseq(p1,p2,eps): # judge if the positions p1 and p2 equal within tolerance eps
        (x1,y1,z1)=p1;   (x2,y2,z2)=p2;     (s1,s2,s3)=[0]*3 
        (d1,d2,d3)=abs(np.array(p2)-p1)
        (t1,t2,t3)=[False]*3
        if(d1<eps):     t1=True; s1=0
        elif(1-d1<eps): t1=True; s1=-1 if x2>x1 else 1; d1=1-d1
        if(d2<eps):     t2=True; s2=0
        elif(1-d2<eps): t2=True; s2=-1 if y2>y1 else 1; d2=1-d2
        if(d3<eps):     t3=True; s3=0
        elif(1-d3<eps): t3=True; s3=-1 if z2>z1 else 1; d3=1-d3      
        return t1 and t2 and t3, max(d1,d2,d3), [s1,s2,s3]        
    cf=ReadCif(filename)
    data=cf[cf.keys()[0]]
    #-------------construct the basic lattice vectors--------------
    a=rmprs(data['_cell_length_a'])
    b=rmprs(data['_cell_length_b'])
    c=rmprs(data['_cell_length_c'])
    alpha=rmprs(data['_cell_angle_alpha'])*np.pi/180
    beta=rmprs(data['_cell_angle_beta'])*np.pi/180
    gamma=rmprs(data['_cell_angle_gamma'])*np.pi/180
    latt=[[0]*3]*3
    latt[0]=[a,0,0]
    latt[1]=[b*cos(gamma),b*sin(gamma),0]
    tmp1=c*cos(beta)
    tmp2=c*(cos(alpha)/sin(gamma)-cos(beta)/tan(gamma))
    latt[2]=[tmp1,tmp2,sqrt(c**2-tmp1**2-tmp2**2)]
    latt=chop(latt)
    #----------------------------------------------------------------
    xs1=rmprs(data['_atom_site_fract_x'])
    ys1=rmprs(data['_atom_site_fract_y'])
    zs1=rmprs(data['_atom_site_fract_z'])
    pos1=np.array([xs1,ys1,zs1]).T
    atmL1=data['_atom_site_label']
    atmL1=list(map(lambda s:re.sub('[0-9]','',s),atmL1))
    occ=rmprs(data['_atom_site_occupancy'])
    if(np.array(occ)<1).any(): print("Warning: fractional occupations exist!")
    if('_atom_site_symmetry_multiplicity' in data.keys()):
        multi=list(map(int,data['_atom_site_symmetry_multiplicity']))
        has_multi=True
    else: has_multi=False
    for k in data.keys(): 
        if k.find('_xyz')>-1: symkey=k
    # the key for xyz symmetry operations may be '_symmetry_equiv_pos_as_xyz'
    #                                   or '_space_group_symop_operation_xyz'
    symxyz=data[symkey]
    # pos1[i] is the position of each inequivalent atom under symmetry
    # pos2[i] is a list of all positions equivalent to pos1[i] under the transformation
    #         symxyz. pos2[i] has duplicate positions. 
    # pos[i]  is the list of equivalent positions of pos1[i] with all duplicate
    #         ones removed. len(pos[i]) should equal to multi[i] if the latter exists.
    #----------------generate pos2 according to symxyz----------------------
    pos2=[]
    for p in pos1:
        tmp=[]
        for xyz in symxyz:
            (x,y,z)=p;    x1,y1,z1=eval(xyz)
            tmp.append([x1,y1,z1])
        pos2.append(tmp)
    pos2=mymod(pos2,1)
    #---------------generate pos by removing duplication--------------------
    pos=[];   mindiff=[1e8]*len(pos2)
    for k,p in enumerate(pos2):  
        idx=list(range(len(p)))
        for i,pi in enumerate(p):
            if idx[i]==-1: continue 
            for j in range(i+1,len(p)):
                pj=p[j]
                eq,diff,s=poseq(pi,pj,symprec)
                if(eq): idx[j]=-1
                if(symprec < diff < mindiff[k]): mindiff[k]=diff
#        print('mindiff=',mindiff[k])
        idx=np.unique(idx).tolist()
        if -1 in idx: idx.remove(-1)
#        print("idx: ",idx)
        pos.append(np.array(p)[idx])
    mymul=list(map(len,pos))
    allpos=[];   alllabels=[]
    for i,j in enumerate(mymul):
        allpos+=pos[i].tolist();    alllabels+=[atmL1[i]]*j
    atom_numbers=list(map(lambda L:atom_label2number[L],alllabels))
    #-----------------------------------------------------------------------
    if not has_multi: return (latt,allpos,atom_numbers)
    tmp=(np.array(mymul)==multi)
#   print(tmp)
    if(tmp.all()):    return (latt,allpos,atom_numbers)
    #-----------the following is for mymul!=multi --------------------------
    # If len(pos[i])>multi[i], then not all duplications are removed in pos[i].
    # In this case, we use a larger tolerance mindiff[k]*2 to redo the 
    # duplication-removing procedure.
    for k in (i for i in range(len(tmp)) if tmp[i]==False):
#            print("pos2:\n",np.array(pos2[k]))
#            print("pos:\n",pos[k].tolist())
        p=pos[k]
        idx=list(range(len(p)))
        for i,pi in enumerate(p):
            if idx[i]==-1: continue 
            for j in range(i+1,len(p)):
                pj=p[j]
                eq,diff,s=poseq(pi,pj,mindiff[k]*2)
                if(eq): idx[j]=-1
        idx=np.unique(idx).tolist()
        if -1 in idx: idx.remove(-1)
#        print("idx: ",idx)
        pos[k]=np.array(p)[idx]
#            print("pos(new):\n",pos[k].tolist())
#            print(" # ", len(pos[k])==multi[k])
    #-----------------------------------------------------------------------
    allpos=[];   alllabels=[]
    mymul=list(map(len,pos))
    for i,j in enumerate(mymul):
        allpos+=pos[i].tolist();    alllabels+=[atmL1[i]]*j
    atom_numbers=list(map(lambda L:atom_label2number[L],alllabels))
    return (latt,allpos,atom_numbers)

def getSGoperations(dataset):
    spgnum=dataset['number']   
    p0=dataset['origin_shift']
    Ri=dataset["rotations"];   vi=dataset["translations"]   # input operations
    P=dataset["transformation_matrix"]
    (Q,S)=Q_and_S_from_spg_to_BC(spgnum,dataset['std_lattice'])
    Rs=[0]*len(Ri);        vs=[0]*len(Ri)        # spglib standard operations, the same as ITA
    RBC2=[0]*len(Ri);      vBC2=[0]*len(Ri)      # operatioons for the 2nd line in BC Tab.3.7, ITA setting, BC basic vectors
    RBC1=[0]*len(Ri);      vBC1=[0]*len(Ri)      # operatioons for the 1st line in BC Tab.3.7
    (gen1,t0,U,gen2)=SG_gen_elem[spgnum]
    for j in range(len(Ri)):
        Rs[j]=np.array(np.round(P@Ri[j]@np.mat(P).I).astype(int))
        vs[j]=np.dot(P,vi[j])+p0-np.dot(Rs[j],p0)
        RBC2[j]=np.array(np.mat(Q).I@Rs[j]@Q)
        vBC2[j]=np.array(np.dot(np.mat(Q).I, vs[j]))[0]
        RBC1[j]=np.array(np.mat(U).I@RBC2[j]@U)
        vBC1[j]=np.array(np.dot(np.mat(U).I, vBC2[j]))[0]
        vBC1[j]=vBC1[j]+t0-np.dot(RBC1[j],t0)
    #--------------check if gen1 is corresponding to gen2 one by one----------
    if gen2!=[]:
        gen1_from2=[0]*len(gen1)
        for i in range(len(gen1)):
            R2=get_BC_rot_mat(spgnum,gen2[i][0],'A')
            v2=gen2[i][1]
            R1_from2=np.array(np.mat(U).I@R2@U)
            v1_from2=np.array(np.dot(np.mat(U).I, v2))[0]
            v1_from2=v1_from2+t0-np.dot(R1_from2,t0)
            gen1_from2[i]=[get_BC_rot_name(spgnum,R1_from2), v1_from2] 
        gen1_from2=list(map(lambda g: [g[0],np.round(np.round(g[1],4)%1,4).tolist()], gen1_from2))
        gen1_round=list(map(lambda g: [g[0],np.round(g[1],4).tolist()], gen1))
#       print('#No. %3d gen1_round==gen1_from2: '%spgnum,(gen1_round==gen1_from2))
#       print('gen1_round: ',gen1_round)
#       print('gen1_from2: ',gen1_from2)
    #--------------begin check BC Tab.3.7-------------------
    ndig=4
    gen1=list(map(lambda g: [g[0],np.round(g[1],ndig)], gen1))
    gen2=list(map(lambda g: [g[0],np.round(g[1],ndig)], gen2))
    set_gen1=set(list2tuple(gen1))
    set_gen2=set(list2tuple(gen2))
    set_BC1=[0]*len(Ri);     set_BC2=[0]*len(Ri)
    for j in range(len(Ri)):
        set_BC1[j]=[get_BC_rot_name(spgnum,RBC1[j]),np.round(np.round(vBC1[j],ndig)%1,ndig)]
        set_BC2[j]=[get_BC_rot_name(spgnum,RBC2[j],'A' if 38<=spgnum<=41 else 'C'),np.round(np.round(vBC2[j],ndig)%1,ndig)]
    set_BC1=set(list2tuple(set_BC1))
    set_BC2=set(list2tuple(set_BC2))
    if (U==np.eye(3)).all(): star=""
    elif (U==-np.eye(3)).all(): star="(tbd)"
    else: star="(*)"
    if not (t0==np.zeros(3)).all(): star+=" (t)"
#   print(("#No. %3d "+star)%spgnum, "gen1 in BC1 and gen2 in BC2:",set_gen1.issubset(set_BC1), set_gen2.issubset(set_BC2))
#   print('gen1:',set_gen1);  print('gen2:',set_gen2);   print('BC1:',set_BC1);   print('BC2:',set_BC2);  print()
    #--------------end  check BC Tab.3.7-------------------
    return {  'input_rot': np.array(Ri),     'input_trans': np.array(vi),
            'spg_std_rot': np.array(Rs),   'spg_std_trans': np.array(vs),
             'BC_ITA_rot': np.array(RBC2),  'BC_ITA_trans': np.array(vBC2),
                 'BC_rot': np.array(RBC1),      'BC_trans': np.array(vBC1) }
       
def get_BZ_type(sgno, LBC):
    brav=getSGlatt(sgno)
    if brav in ("TricPrim","MonoPrim","MonoBase","OrthPrim","TetrPrim","HexaPrim",
                "CubiPrim","CubiFace","CubiFace"): return brav
    if brav=="OrthBase":
        a=2*LBC[0,0];   b=-2*LBC[0,1]
        BZtype=("a" if a>b else "b")
    if brav=="OrthBody":
        a,b,c=2*LBC[0]
        if   a==max(a,b,c): BZtype="a"
        elif b==max(a,b,c): BZtype="b"
        elif c==max(a,b,c): BZtype="c"
    if brav=="OrthFace":
        a=2*LBC[0,0];   b=-2*LBC[1,1];  c=2*LBC[0,2]
        BZtype="a"
        if 1/c**2>1/a**2+1/b**2: BZtype="b"
        if 1/b**2>1/a**2+1/c**2: BZtype="c"
        if 1/a**2>1/c**2+1/b**2: BZtype="d"
    if brav=="TetrBody":
        a=2*LBC[0,1];   c=2*LBC[0,2]
        BZtype=("a" if a>c else "b")
    if brav=="TrigPrim":
        a=-LBC[0,1];    c=LBC[0,2]
        BZtype=("a" if a>sqrt(2)*c else "b")
    return brav+"("+BZtype+")"

def print_dataset(dataset, prec=1e-5):
    spgnum=dataset['number']   
    p0=dataset['origin_shift']
    print("# Space group: %s %3d"%(dataset['international'],spgnum),'\n')
    Ri=dataset["rotations"];   vi=dataset["translations"]
    P=dataset["transformation_matrix"]
    ops=getSGoperations(dataset)
    Rs=ops['spg_std_rot'];     vs=ops['spg_std_trans']
    RBC2=ops['BC_ITA_rot'];    vBC2=ops['BC_ITA_trans']
    RBC1=ops['BC_rot'];        vBC1=ops['BC_trans']
    print('# Symmetry operations:')
    print('# (R0,v0):      Operations on the input structure.')
    print('# (Rs,vs):      Standard operations in spglib, the same as ITA, using conventional basic vectors.')
    print('# (RBC2,vBC2):  The operations in the 2nd line of my revised BC Tab.3.7, transformed from the standard ITA\n#'+' '*14,
                          'operations by Q matrix, using the BC basic vectors in Tab.3.1 [note(v) for space group 38-41].')
    print('# (RBC1,vBC1):  The operations using by BC, i.e. the 1st line of BC Tab.3.7.\n')
    print('#    (R0,v0)',' '*23,'(Rs,vs)',' '*21,'(RBC2,vBC2)',' '*21,'(RBC1,vBC1)')
    for j in range(len(Ri)):
        print("# %-4d:"%(j+1), "%-5s"%getJonesOper(Ri[j],spgnum)," "*25,"%-5s"%getJonesOper(Rs[j],spgnum), " "*25, 
              "%-5s"%get_BC_rot_name(spgnum,RBC2[j],'A' if 38<=spgnum<=41 else 'C')," "*25,
              "%-5s"%get_BC_rot_name(spgnum,RBC1[j]))
        for k in (0,1,2): 
            print("%4d%4d%4d  "%tuple(Ri[j,k]),   "%- 12.8f"%chop(vi[j,k]),  " "*4, end="")
            print("%4d%4d%4d  "%tuple(Rs[j,k]),   "%- 12.8f"%chop(vs[j,k]),  " "*4, end="")
            print("%4g%4g%4g  "%tuple(RBC2[j,k]), "%- 12.8f"%chop(vBC2[j,k])," "*4, end="")
            print("%4g%4g%4g  "%tuple(RBC1[j,k]), "%- 12.8f"%chop(vBC1[j,k]))
    print()
    (Q,S)=Q_and_S_from_spg_to_BC(spgnum,dataset['std_lattice'])
    (gen1,t0,U,gen2)=SG_gen_elem[spgnum]
    cells=get_all_cells(dataset, prec)
    L0  =cells[1][0];      Ls  =cells[2][0];      Lsi =cells[3][0]
    LBC2=cells[4][0];      LBC1=cells[5][0];      LBC =cells[6][0]
    print('# transformation_matrix [P]: (a0,b0,c0)=(as,bs,cs).P, and  origin_shift p0 = O - Os:')
    for i,j in zip(P,p0):
        print("   %- 16.11g %- 16.11g %- 16.11g" % tuple(chop(i)), "% 28.10f"%chop(j))
    print("# std_rotation_matrix   (R): (as',bs',cs')=(R.as,R.bs,R.cs)")
    for i in dataset['std_rotation_matrix']: print("   %- 16.11g %- 16.11g %- 16.11g" % tuple(chop(i)))
    print("# transformation matrix [Q]: (t1BC2,t2BC2,t3BC2)=(as',bs',cs').Q")
    for i in Q: print("   %- 16.11g %- 16.11g %- 16.11g" % tuple(chop(i)))
    print("# transformation matrix [U]:  and origin shift t0 = OBC2-OBC1: (t1BC1,t2BC1,t3BC1)=(t1BC2,t2BC2,t3BC2).U")
    for i,j in zip(U,t0):
        print("   %- 16.11g %- 16.11g %- 16.11g" % tuple(chop(i)), "% 28.10f"%chop(j))
    print("# rotation matrix       (S): (t1,t2,t3)=S.(t1BC1,t2BC1,t3BC1)")
    for i in S: print("   %- 16.11g %- 16.11g %- 16.11g" % tuple(chop(i)))
    print("\n%-30s %-30s %-30s"%("L0  =(a0,b0,c0)^T","Ls  =(as,bs,cs)^T","Lsi=(as',bs',cs')^T"))
    print(  "%-30s %-30s %-30s"%("LBC2=(t1BC2,t2BC2,t3BC2)^T","LBC1=(t1BC1,t2BC1,t3BC1)^T","LBC=(t1,t2,t3)^T"))
    print("Lattice change process, standardization first, then idealization, then to BC lattices.")
    print("    L0  ==[P^-1]==>  Ls  ==(R)==>  Lsi  ==[Q]==>  LBC2  ==[U]==>  LBC1  ==(S)==>  LBC")
    print(" (R0,v0)          (Rs,vs)       (Rs,vs)        (RBC2,vBC2)     (RBC1,vBC1)     (RBC1,vBC1)\n")
    ndig=10
    L0=np.around(L0,ndig);       Ls=np.around(Ls,ndig);        Lsi=np.around(Lsi,ndig)
    LBC2=np.around(LBC2,ndig);   LBC1=np.around(LBC1,ndig);    LBC=np.around(LBC,ndig)
    print(" "*15+"(1). L0".ljust(39)+"(2). Ls".ljust(39)+"(3). Lsi")
    print(  " [%- 10.7g %- 10.7g %- 10.7g]  " % tuple(L0[0]), end="")
    print("   [%- 10.7g %- 10.7g %- 10.7g]  " % tuple(Ls[0]), end="")
    print("   [%- 10.7g %- 10.7g %- 10.7g]  " % tuple(Lsi[0]))
    print(  " |%- 10.7g %- 10.7g %- 10.7g| =" % tuple(L0[1]), end="")
    print(">  |%- 10.7g %- 10.7g %- 10.7g| =" % tuple(Ls[1]), end="")
    print(">  |%- 10.7g %- 10.7g %- 10.7g|  " % tuple(Lsi[1]))
    print(  " [%- 10.7g %- 10.7g %- 10.7g]  " % tuple(L0[2]), end="")
    print("   [%- 10.7g %- 10.7g %- 10.7g]  " % tuple(Ls[2]), end="")
    print("   [%- 10.7g %- 10.7g %- 10.7g]  " % tuple(Lsi[2]),"\n")
    print(" "*15+"(4). LBC2".ljust(39)+"(5). LBC1".ljust(39)+"(6). LBC")
    print(  " [%- 10.7g %- 10.7g %- 10.7g]  " % tuple(LBC2[0]), end="")
    print("   [%- 10.7g %- 10.7g %- 10.7g]  " % tuple(LBC1[0]), end="")
    print("   [%- 10.7g %- 10.7g %- 10.7g]  " % tuple(LBC[0]))
    print(  " |%- 10.7g %- 10.7g %- 10.7g| =" % tuple(LBC2[1]), end="")
    print(">  |%- 10.7g %- 10.7g %- 10.7g| =" % tuple(LBC1[1]), end="")
    print(">  |%- 10.7g %- 10.7g %- 10.7g|  " % tuple(LBC[1]))
    print(  " [%- 10.7g %- 10.7g %- 10.7g]  " % tuple(LBC2[2]), end="")
    print("   [%- 10.7g %- 10.7g %- 10.7g]  " % tuple(LBC1[2]), end="")
    print("   [%- 10.7g %- 10.7g %- 10.7g]  " % tuple(LBC[2]),"\n")
    print("BZ type is: ",get_BZ_type(spgnum,LBC), "\n")


#-----------------------------main program--------------------------
if __name__=='__main__':
    #---------------------------------命令行参数解析-----------------------------------------
    parser=argparse.ArgumentParser(description="The funciton of %(prog)s is to get the space group symmetry from the structure file of vasp (POSCAR is default) or cif file through spglib, and then convert the lattice and symmetry operations to the convention used by C.J. Bradley and A.P. Cracknell in their book \"The Mathematical Theory of Symmetry in Solids\".", epilog="By gbliu", prefix_chars="-", formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("-f", "--file", help="The vasp structure file.", default="POSCAR")
    parser.add_argument("-c", "--cif", help="The cif structure file.")
    parser.add_argument("-o", "--output", help="Switch on output of vasp structure file.", action="store_true", default=False)
    parser.add_argument("-s", "--select", help="Select which structures to output. Choices are 1 to 6, or a for all, or\
                                                any combination of 1 to 6, e.g. 16 means 1 and 6.", default="6")
    parser.add_argument("-F", "--output_file", help="Base name for the output vasp structure file.", default="[auto]")
    parser.add_argument("-p", "--prec", help="The precion for determine symmetries.", default=1e-5, type=float)
    args = parser.parse_args(sys.argv[1:])
    if '-c' in sys.argv and '-f' in sys.argv:
        print("\n Only one of -c and -f can be used!\n");  exit(1)
    if '-c' in sys.argv:
        filetype='cif';       input_file_name=args.cif
        if not os.path.isfile(args.cif):
            print("\n There is no cif file "+args.cif+", use -h option to see help.\n");  exit(1)
    else:
        filetype='vasp';      input_file_name=args.file
        if not os.path.isfile(args.file):
            print("\n There is no vasp sctucture file "+args.file+", use -h option to see help.\n");  exit(1)
    #----------------------------------------------------------------------------------------

    if filetype=="cif":
        input_cell=myreadcif(args.cif, symprec=args.prec)
    elif filetype=="vasp":
        input_cell=read_poscar(args.file)
    
    dataset=spg.get_symmetry_dataset(input_cell, symprec=args.prec)
    
    if dataset==None:
        print("No symmetry found! Please check if the input structure is wrong.")
        exit(1)
    
    #sp=dataset['international']
    #spno=int(dataset['number'])
    print_dataset(dataset, args.prec)

    filename=args.output_file if args.output_file!="[auto]" else input_file_name
    if args.output: output_poscar(dataset, filename, args.select, args.prec)
    
    #import seekpath
    #print(seekpath.get_explicit_k_path(input_cell))
    #print(seekpath.get_path(input_cell))
    
    #print(get_all_cells(dataset, args.prec))
    # print(args.output)
    #print(args.select)
    
    #getSGoperations(dataset)
    #print(args.cif,": ",sp,spno,int(re.sub("_.*","",os.path.basename(args.cif)))==spno)
